function assignPassengersToRides() public {
    // 复制等待列表以避免在迭代时修改原始映射
    PassengerWaitlist[] memory waitlist = new PassengerWaitlist[](passengerWaitlist.length);
    for (address passengerAddr; passengerAddr < passengerWaitlist.length; ++passengerAddr) {
        waitlist[passengerAddr] = passengerWaitlist[passengerAddr];
    }

    // 排序乘客，优先考虑最接近首选时间的乘客
    // 这里使用了一个简单的排序算法，根据需要可能需要更高效的排序方法
    for (uint i = 0; i < waitlist.length - 1; i++) {
        for (uint j = i + 1; j < waitlist.length; j++) {
            if (waitlist[i].preferredTravelTime > waitlist[j].preferredTravelTime) {
                // 交换两个乘客的位置
                (waitlist[i], waitlist[j]) = (waitlist[j], waitlist[i]);
            }
        }
    }

    // 为每个乘客分配乘车
    for (uint i = 0; i < waitlist.length; ++i) {
        PassengerWaitlist storage passenger = waitlist[i];
        if (passenger.isAssigned) continue;

        // 查找最接近首选时间的可用乘车
        AvailableRide memory bestRide = findBestAvailableRide(passenger.source, passenger.destination, passenger.preferredTravelTime);

        if (bestRide.isFullyBooked) {
            // 如果没有找到合适的乘车，退还押金
            payable(passengerAddr).transfer(passenger.deposit);
            continue;
        }

        // 为乘客分配乘车
        assignPassengerToRide(passenger, bestRide.rideId, bestRide.travelTime);
    }
}

// 辅助函数，为乘客分配乘车
function assignPassengerToRide(PassengerWaitlist storage passenger, uint256 rideId, uint8 travelTime) private {
    // 更新乘客信息
    passenger.isAssigned = true;
    // 更新乘车的可用座位数
    Ride storage ride = rides[rideId];
    ride.availableSeats--;

    // 如果乘车已满，更新状态并从可用乘车列表中移除
    if (ride.availableSeats == 0) {
        ride.status = RideStatus.FullyBooked;
        for (uint i = 0; i < availableRides.length; i++) {
            if (availableRides[i].rideId == rideId) {
                availableRides[i] = availableRides[availableRides.length - 1];
                availableRides.pop();
                break;
            }
        }
    }

    // 添加乘客到乘车的乘客列表
    ride.passengerAddr.push(passengerAddr);

    // 处理支付转移给司机
    payable(ride.driver).transfer(passenger.deposit);

    // 触发事件
    emit RideJoined(rideId, passengerAddr);
}

// 辅助函数，查找最适合乘客的可用乘车
function findBestAvailableRide(Location source, Location destination, uint8 preferredTravelTime) private view returns (AvailableRide memory) {
    uint8 minDeviation = 255; // 假设一天有24小时，用255作为初始最大偏差值
    AvailableRide memory bestRide;

    for (AvailableRide storage ride : availableRides) {
        if (ride.origin == source && ride.destination == destination && !ride.isFullyBooked) {
            uint8 deviation = uint8(abs(int(preferredTravelTime) - int(ride.travelTime)));
            if (deviation < minDeviation) {
                minDeviation = deviation;
                bestRide = ride;
            }
        }
    }

    return bestRide;
}